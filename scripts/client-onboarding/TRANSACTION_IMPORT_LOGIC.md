# Transaction Import Logic Documentation

## Overview
This document details the complex logic used in the transaction import process for client onboarding, focusing on the critical algorithms and data transformations.

## Transaction ID Generation Algorithm

### Current Implementation (as of July 25, 2025)
The transaction ID generation is implemented in `/backend/utils/databaseFieldMappings.js`:

**Format:** `YYYY-MM-DD_HHMMSS_nnn`

**Key Features:**
1. **Timezone-aware:** Always uses America/Cancun (UTC-5, no DST)
2. **Uniqueness guarantee:** Implements retry mechanism with collision detection
3. **Dual-mode operation:**
   - For new transactions: Uses current timestamp
   - For historical imports: Preserves user-selected date but uses current time components

**Algorithm Details:**
```javascript
generateTransactionId: async (isoDateString) => {
    // 1. Initialize collision detection
    if (!global._recentTransactionIds) {
        global._recentTransactionIds = new Set();
    }
    
    // 2. Retry loop for uniqueness (max 5 attempts)
    while (retryCount < maxRetries) {
        let dt;
        
        if (isoDateString) {
            // Historical import: preserve date, use current time
            dt = DateTime.fromISO(isoDateString, { zone: 'America/Cancun' });
            const now = DateTime.now().setZone('America/Cancun');
            dt = dt.set({
                hour: now.hour,
                minute: now.minute,
                second: now.second,
                millisecond: now.millisecond
            });
        } else {
            // New transaction: use full current timestamp
            dt = DateTime.now().setZone('America/Cancun');
        }
        
        // 3. Format as YYYY-MM-DD_HHMMSS_nnn
        const transactionId = `${year}-${month}-${day}_${hours}${minutes}${seconds}_${ms}`;
        
        // 4. Check for collisions
        if (!global._recentTransactionIds.has(transactionId)) {
            // Add to recent set with 1-second cleanup
            return transactionId;
        }
        
        // 5. Wait 2ms and retry if collision
    }
    
    // 6. Fallback: append random suffix if all retries failed
}
```

### Import Script ID Generation
The import script (`import-transactions-with-crud.js.backup`) uses a different approach:

```javascript
// Line 106-113: Generates temporary ID for linking
function generateTransactionDocId(transaction) {
    const date = new Date(transaction.Date);
    const dateStr = date.toISOString().split('T')[0].replace(/-/g, '');
    const categoryId = transaction.Category.toLowerCase().replace(/\s+/g, '').substring(0, 10);
    const sequence = transaction[""] || transaction.originalIndex;
    
    return `${dateStr}-${categoryId}-${sequence}`;
}
```

**Note:** This temporary format is NOT the final transaction ID. The actual ID is generated by the `createTransaction` controller method.

## Account Name to ID Mapping

### Account Resolution Process
1. **Import Script Augmentation** (`data-augmentation-utils.js`):
   ```javascript
   // Lines 155-175: augmentMTCTransaction
   const accountMapping = getMTCImportMapping();
   const mapping = accountMapping[accountName];
   
   return {
       accountId: mapping?.accountId || null,
       accountType: mapping?.accountType || null,
       account: mapping?.account || accountName,
       // ... other fields
   }
   ```

2. **Controller Resolution** (`transactionsController.js`):
   - Priority: IDs over names
   - If accountId provided: resolve to accountName
   - If only accountName provided: resolve to accountId
   - Store both ID and name for quick access

### Account Mapping Configuration
Located in `/backend/utils/accountMapping.js`, defines:
- `accountId`: Unique identifier for the account
- `accountType`: bank/cash/credit/etc.
- `account`: Display name

## Category/Subcategory Resolution

### Category Handling
1. **Special Cases:**
   - Split transactions use categoryId: `"-split-"` â†’ categoryName: `"-Split-"`
   - HOA Dues transactions get special metadata

2. **Resolution Process:**
   ```javascript
   // Lines 73-93: resolveCategoryId
   async function resolveCategoryId(clientId, categoryName) {
       // Query categories collection by name
       const categoriesSnapshot = await db.collection(`clients/${clientId}/categories`)
           .where('name', '==', categoryName)
           .limit(1)
           .get();
       
       if (!categoriesSnapshot.empty) {
           return categoriesSnapshot.docs[0].id;
       }
       
       // Return null if not found (store name only)
   }
   ```

3. **Category Type Detection:**
   - Queries category document to determine if expense/income
   - Defaults to 'expense' if type not specified

## Split Transaction Handling

### Import Process
The import script doesn't directly handle split transactions during initial import. Instead:

1. **Parent Transaction:** Marked with category "Split" or "-split-"
2. **Split Items:** Stored in `splits` array field on parent transaction
3. **Structure:**
   ```javascript
   {
       categoryId: "-split-",
       amount: totalAmount, // Sum of all splits
       splits: [
           {
               categoryId: "category1",
               categoryName: "Category 1",
               amount: 1000, // in cents
               percentage: 50
           },
           // ... more split items
       ]
   }
   ```

## Balance Calculations

### During Import
1. **Amount Storage:** All amounts converted to cents (x100)
2. **Balance Updates:** Handled by `updateAccountBalance` after transaction creation
3. **Process:**
   ```javascript
   // In createTransaction:
   const updateResult = await updateAccountBalance(
       clientId,
       finalAccountId,
       finalAmount,
       normalizedData.type
   );
   ```

### Balance Tracking
- Each account maintains running balance
- Updates are atomic using Firestore transactions
- Balance changes logged in audit trail

## Date Parsing and Timezone Handling

### Timezone Configuration
- **Fixed timezone:** America/Cancun (UTC-5, no DST)
- **All dates stored as if in Cancun time**

### Date Processing Pipeline

1. **Import Data Parsing:**
   ```javascript
   // Original date from JSON
   mtcTransaction.Date // e.g., "2024-12-27T21:27:51.922Z"
   ```

2. **Normalization in Controller:**
   ```javascript
   // convertToTimestamp logic:
   const cancunDateStr = date.toLocaleDateString("en-CA", {
       timeZone: "America/Cancun",
       year: "numeric",
       month: "2-digit",
       day: "2-digit"
   });
   
   const cancunTimeStr = date.toLocaleTimeString("en-CA", {
       timeZone: "America/Cancun",
       hour12: false,
       hour: "2-digit",
       minute: "2-digit",
       second: "2-digit"
   });
   
   // Reconstruct preserving Cancun time
   const localDateTime = new Date(`${cancunDateStr}T${cancunTimeStr}`);
   return admin.firestore.Timestamp.fromDate(localDateTime);
   ```

3. **API Response Formatting:**
   ```javascript
   // formatDateField returns multi-format object:
   {
       display: "Dec 27, 2024",          // Human-readable
       iso: "2024-12-27T21:27:51-05:00", // ISO with TZ offset
       timestamp: 1735346871922,          // Unix timestamp
       components: {
           year: 2024,
           month: 12,
           day: 27,
           dayOfWeek: "Friday"
       }
   }
   ```

### Critical Date Handling Rules
1. **Storage:** All timestamps stored as Firestore Timestamp objects
2. **Input:** Accept ISO strings, Unix timestamps, Date objects
3. **Output:** Always include timezone offset (-05:00)
4. **Display:** Use Cancun timezone for all user-facing dates

## Import Workflow

### Step-by-Step Process

1. **Load Transaction Data:**
   - Read from `MTCdata/Transactions.json`
   - Contains raw transaction records with Google Sheets IDs

2. **Augment Each Transaction:**
   - Map account names to IDs
   - Add metadata fields
   - Preserve original data for audit

3. **Extract HOA Dues Info:**
   ```javascript
   // Lines 68-77: Special handling for HOA Dues
   if (txnData.Category === 'HOA Dues' && txnData.Unit) {
       const unitId = extractUnitId(txnData.Unit);
       if (unitId) {
           augmentedTxn.unitId = unitId;
           augmentedTxn.metadata = {
               type: 'hoa_dues',
               originalUnit: txnData.Unit
           };
       }
   }
   ```

4. **Create Transaction via CRUD:**
   - Validates against schema
   - Generates proper transaction ID
   - Updates account balances
   - Creates audit log

5. **Track HOA Dues Transactions:**
   ```javascript
   // Lines 127-135: Track for cross-referencing
   if (txnData.Category === 'HOA Dues') {
       results.hoaDuesTransactions.push({
           transactionId,
           unitId: augmentedTxn.unitId,
           amount: txnData.Amount,
           date: txnData.Date,
           googleId: txnData[''] || `seq_${index + 1}`
       });
   }
   ```

6. **Save Transaction Mapping:**
   - Creates `transaction-id-mapping.json`
   - Maps Google Sheet IDs to Firestore transaction IDs
   - Used by HOA dues import for linking

## Error Handling

### Validation Errors
- Schema validation before creation
- Account mapping validation
- Amount and date format validation

### Recovery Mechanisms
1. **Partial Import Support:** Tracks success/error counts
2. **Detailed Logging:** First 3 errors show full details
3. **Audit Trail:** All successful imports logged

### Common Import Issues
1. **Missing Account Mapping:** Falls back to storing account name only
2. **Invalid Dates:** Uses current date as fallback
3. **Category/Vendor Not Found:** Stores name without ID reference

## Data Integrity

### Consistency Checks
1. **Account Balance:** Updated atomically with transaction creation
2. **Audit Logging:** Automatic via CRUD operations
3. **ID Uniqueness:** Guaranteed by generation algorithm

### Cross-Reference Requirements
- HOA Dues transactions must maintain googleId for linking
- Transaction IDs must be stable after creation
- Account balances must reflect all imported transactions

## Performance Considerations

### Batch Processing
- Processes transactions sequentially (not batch)
- Ensures proper balance calculations
- Allows for detailed error tracking

### ID Generation Optimization
- Uses in-memory collision detection
- 1-second cleanup of recent IDs
- Retry mechanism with minimal delay (2ms)

### Memory Management
- Streams large JSON files
- Cleans up tracking sets after use
- Limits error detail logging to first few items