import { writeFile, mkdir } from 'fs/promises';
import { resolve, join } from 'path';
import { logger } from './logger';
import { getCacheClearScript } from './cache-buster';
import { VersionManager } from './version-manager';

export interface BuildScriptConfig {
  projectPath: string;
  environment: 'development' | 'staging' | 'production';
  target: 'desktop' | 'mobile';
  enableCacheBusting: boolean;
  enableVersionNotifications: boolean;
}

/**
 * Environment-aware build script generator
 * Creates optimized build configurations for each environment and target
 */
export class BuildScriptGenerator {
  private config: BuildScriptConfig;

  constructor(config: BuildScriptConfig) {
    this.config = config;
  }

  /**
   * Generate all build scripts and configuration files
   */
  async generateBuildConfiguration(): Promise<void> {
    logger.info('üîß Generating environment-aware build configuration...');

    try {
      // Create build scripts directory
      const scriptsDir = join(this.config.projectPath, 'build-scripts');
      await mkdir(scriptsDir, { recursive: true });

      // Generate environment-specific build script
      await this.generateEnvironmentBuildScript();

      // Generate cache-busting integration script
      if (this.config.enableCacheBusting) {
        await this.generateCacheBustingScript();
      }

      // Generate version notification integration
      if (this.config.enableVersionNotifications) {
        await this.generateVersionNotificationIntegration();
      }

      // Generate deployment verification script
      await this.generateDeploymentVerificationScript();

      // Generate rollback script
      await this.generateRollbackScript();

      // Update package.json with new scripts
      await this.updatePackageJsonScripts();

      logger.success('‚úÖ Build configuration generated successfully');

    } catch (error) {
      logger.error(`‚ùå Build configuration generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
      throw error;
    }
  }

  /**
   * Generate environment-specific build script
   */
  private async generateEnvironmentBuildScript(): Promise<void> {
    const scriptPath = join(this.config.projectPath, 'build-scripts', `build-${this.config.environment}.sh`);
    
    const buildScript = `#!/bin/bash
# SAMS ${this.config.target} Build Script for ${this.config.environment}
# Auto-generated by cache-busting system

set -e # Exit on any error

echo "üöÄ Starting ${this.config.target} build for ${this.config.environment} environment..."

# Environment variables
export NODE_ENV="${this.config.environment === 'development' ? 'development' : 'production'}"
export VITE_APP_ENV="${this.config.environment}"
export VITE_BUILD_TIME="$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)"
export VITE_BUILD_TIMESTAMP="$(date +%s)"
export VITE_CACHE_BUST="$(date +%s)-$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 8)"

# Set API URLs based on environment
case "${this.config.environment}" in
  production)
    export VITE_API_BASE_URL="https://sams-sandyland-prod-default-rtdb.firebaseio.com"
    export VITE_USE_EMULATOR="false"
    ;;
  staging)
    export VITE_API_BASE_URL="https://sams-sandyland-staging-default-rtdb.firebaseio.com"
    export VITE_USE_EMULATOR="false"
    ;;
  *)
    export VITE_API_BASE_URL="http://localhost:9000"
    export VITE_USE_EMULATOR="true"
    ;;
esac

# Clean previous build
echo "üßπ Cleaning previous build..."
rm -rf dist/
rm -rf .vite/

# Install dependencies with legacy peer deps for compatibility
echo "üì¶ Installing dependencies..."
npm install --legacy-peer-deps

# Run build command
echo "üî® Building application..."
if [ "${this.config.target}" = "mobile" ]; then
  # PWA-specific build optimizations
  export VITE_PWA_ENABLED="true"
  export VITE_SW_ENABLED="true"
  npm run build
else
  # Desktop-specific build optimizations
  export VITE_PWA_ENABLED="false"
  export VITE_SW_ENABLED="false"
  npm run build
fi

# Verify build output
echo "üîç Verifying build output..."
if [ ! -d "dist" ]; then
  echo "‚ùå Build failed: dist directory not found"
  exit 1
fi

if [ ! -f "dist/index.html" ]; then
  echo "‚ùå Build failed: index.html not found"
  exit 1
fi

# ${this.config.target === 'mobile' ? 'PWA-specific verification' : 'Desktop-specific verification'}
${this.config.target === 'mobile' ? `
# Verify PWA files
if [ ! -f "dist/manifest.json" ]; then
  echo "‚ùå PWA Build failed: manifest.json not found"
  exit 1
fi

if [ ! -f "dist/sw.js" ]; then
  echo "‚ùå PWA Build failed: service worker not found"
  exit 1
fi

echo "‚úÖ PWA build verification passed"` : `
# Verify desktop build assets
if [ ! -d "dist/assets" ]; then
  echo "‚ùå Desktop build failed: assets directory not found"
  exit 1
fi

echo "‚úÖ Desktop build verification passed"`}

# Generate build report
echo "üìä Generating build report..."
BUILD_SIZE=$(du -sh dist/ | cut -f1)
ASSET_COUNT=$(find dist/ -type f | wc -l)

cat > dist/build-report.json << EOF
{
  "target": "${this.config.target}",
  "environment": "${this.config.environment}",
  "buildTime": "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)",
  "buildSize": "$BUILD_SIZE",
  "assetCount": $ASSET_COUNT,
  "nodeVersion": "$(node --version)",
  "npmVersion": "$(npm --version)",
  "buildId": "$VITE_CACHE_BUST",
  "cacheBustingEnabled": ${this.config.enableCacheBusting ? 'true' : 'false'},
  "versionNotificationsEnabled": ${this.config.enableVersionNotifications ? 'true' : 'false'}
}
EOF

echo "‚úÖ ${this.config.target} build completed successfully for ${this.config.environment}"
echo "üì¶ Build size: $BUILD_SIZE"
echo "üìÑ Asset count: $ASSET_COUNT"
echo "üÜî Build ID: $VITE_CACHE_BUST"
`;

    await writeFile(scriptPath, buildScript);
    logger.debug(`Generated build script: ${scriptPath}`);
  }

  /**
   * Generate cache-busting integration script
   */
  private async generateCacheBustingScript(): Promise<void> {
    const scriptPath = join(this.config.projectPath, 'build-scripts', 'cache-bust.js');
    
    const cacheBustScript = `#!/usr/bin/env node
// SAMS Cache-Busting Script
// Auto-generated by cache-busting system

const fs = require('fs');
const path = require('path');

const DIST_PATH = path.join(__dirname, '..', 'dist');
const CACHE_BUST_ID = process.env.VITE_CACHE_BUST || Date.now().toString();

console.log('üî• Executing cache-busting...');

// Generate cache-clear script for client injection
const cacheClearScript = \`${getCacheClearScript()}\`;

// Write cache-clear script to dist
fs.writeFileSync(
  path.join(DIST_PATH, 'cache-clear.js'),
  cacheClearScript
);

// Update HTML to include cache-clear script
const indexPath = path.join(DIST_PATH, 'index.html');
if (fs.existsSync(indexPath)) {
  let htmlContent = fs.readFileSync(indexPath, 'utf-8');
  
  // Inject cache-clear script
  const scriptTag = '<script src="/cache-clear.js" defer></script>';
  htmlContent = htmlContent.replace('</head>', \`  \${scriptTag}\\n</head>\`);
  
  // Add cache-busting headers
  const cacheHeaders = \`<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <meta name="cache-bust-id" content="\${CACHE_BUST_ID}">\`;
  
  htmlContent = htmlContent.replace('</head>', \`  \${cacheHeaders}\\n</head>\`);
  
  fs.writeFileSync(indexPath, htmlContent);
  console.log('‚úÖ Updated index.html with cache-busting');
}

// Create cache-bust manifest
const manifest = {
  buildId: CACHE_BUST_ID,
  timestamp: new Date().toISOString(),
  environment: process.env.VITE_APP_ENV || 'development',
  target: '${this.config.target}',
  cacheBustingEnabled: true,
  files: []
};

// Scan dist directory for files
function scanDirectory(dir, basePath = '') {
  const files = fs.readdirSync(dir);
  
  files.forEach(file => {
    const filePath = path.join(dir, file);
    const relativePath = path.join(basePath, file);
    const stat = fs.statSync(filePath);
    
    if (stat.isDirectory()) {
      scanDirectory(filePath, relativePath);
    } else {
      manifest.files.push({
        path: relativePath.replace(/\\\\/g, '/'),
        size: stat.size,
        modified: stat.mtime.toISOString()
      });
    }
  });
}

scanDirectory(DIST_PATH);

fs.writeFileSync(
  path.join(DIST_PATH, 'cache-bust-manifest.json'),
  JSON.stringify(manifest, null, 2)
);

console.log(\`‚úÖ Cache-busting completed with ID: \${CACHE_BUST_ID}\`);
console.log(\`üìÑ Processed \${manifest.files.length} files\`);
`;

    await writeFile(scriptPath, cacheBustScript);
    logger.debug(`Generated cache-busting script: ${scriptPath}`);
  }

  /**
   * Generate version notification integration
   */
  private async generateVersionNotificationIntegration(): Promise<void> {
    const scriptPath = join(this.config.projectPath, 'build-scripts', 'version-notifications.js');
    
    const versionManager = new VersionManager(this.config.projectPath, this.config.environment);
    const notificationScript = versionManager.generateVersionNotificationScript();
    
    const integrationScript = `#!/usr/bin/env node
// SAMS Version Notification Integration
// Auto-generated by version management system

const fs = require('fs');
const path = require('path');

const DIST_PATH = path.join(__dirname, '..', 'dist');

console.log('üîî Setting up version notifications...');

// Generate version notification script
const versionScript = \`${notificationScript}\`;

// Write version script to dist
fs.writeFileSync(
  path.join(DIST_PATH, 'version-check.js'),
  versionScript
);

// Update HTML to include version check script
const indexPath = path.join(DIST_PATH, 'index.html');
if (fs.existsSync(indexPath)) {
  let htmlContent = fs.readFileSync(indexPath, 'utf-8');
  
  // Inject version check script
  const scriptTag = '<script src="/version-check.js" defer></script>';
  
  // Only add if not already present
  if (!htmlContent.includes('version-check.js')) {
    htmlContent = htmlContent.replace('</body>', \`  \${scriptTag}\\n</body>\`);
    fs.writeFileSync(indexPath, htmlContent);
    console.log('‚úÖ Added version notification script to index.html');
  } else {
    console.log('‚ÑπÔ∏è Version notification script already present');
  }
}

console.log('‚úÖ Version notifications setup completed');
`;

    await writeFile(scriptPath, integrationScript);
    logger.debug(`Generated version notification integration: ${scriptPath}`);
  }

  /**
   * Generate deployment verification script
   */
  private async generateDeploymentVerificationScript(): Promise<void> {
    const scriptPath = join(this.config.projectPath, 'build-scripts', 'verify-deployment.sh');
    
    const verificationScript = `#!/bin/bash
# SAMS Deployment Verification Script
# Auto-generated by cache-busting system

set -e

DEPLOYMENT_URL="$1"

if [ -z "$DEPLOYMENT_URL" ]; then
  echo "‚ùå Usage: $0 <deployment-url>"
  exit 1
fi

echo "üîç Verifying deployment at: $DEPLOYMENT_URL"

# Test basic connectivity
echo "Testing basic connectivity..."
if ! curl -s -f "$DEPLOYMENT_URL" > /dev/null; then
  echo "‚ùå Deployment URL is not accessible"
  exit 1
fi
echo "‚úÖ Basic connectivity OK"

# Test essential files
ESSENTIAL_FILES=(
  ""
  "manifest.json"
  "cache-bust-manifest.json"
  ${this.config.target === 'mobile' ? '"sw.js"' : ''}
  ${this.config.enableVersionNotifications ? '"version-check.js"' : ''}
)

for file in "\${ESSENTIAL_FILES[@]}"; do
  if [ -n "$file" ]; then
    echo "Testing $file..."
    HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$DEPLOYMENT_URL/$file")
    if [ "$HTTP_CODE" != "200" ]; then
      echo "‚ùå $file returned HTTP $HTTP_CODE"
      exit 1
    fi
    echo "‚úÖ $file OK"
  fi
done

# Test cache-busting headers
echo "Testing cache-busting headers..."
CACHE_HEADERS=$(curl -s -I "$DEPLOYMENT_URL" | grep -i cache-control || true)
if [ -n "$CACHE_HEADERS" ]; then
  echo "‚úÖ Cache headers present: $CACHE_HEADERS"
else
  echo "‚ö†Ô∏è No cache headers found"
fi

# Test version information
if [ "${this.config.enableVersionNotifications}" = "true" ]; then
  echo "Testing version information..."
  VERSION_RESPONSE=$(curl -s "$DEPLOYMENT_URL/cache-bust-manifest.json" | head -c 1000)
  if echo "$VERSION_RESPONSE" | grep -q "buildId"; then
    echo "‚úÖ Version information available"
  else
    echo "‚ö†Ô∏è Version information not found"
  fi
fi

echo "‚úÖ Deployment verification completed successfully"
echo "üåê Deployment URL: $DEPLOYMENT_URL"
echo "üéØ Target: ${this.config.target}"
echo "üåç Environment: ${this.config.environment}"
`;

    await writeFile(scriptPath, verificationScript);
    logger.debug(`Generated deployment verification script: ${scriptPath}`);
  }

  /**
   * Generate rollback script
   */
  private async generateRollbackScript(): Promise<void> {
    const scriptPath = join(this.config.projectPath, 'build-scripts', 'rollback.sh');
    
    const rollbackScript = `#!/bin/bash
# SAMS Rollback Script
# Auto-generated by cache-busting system

set -e

ROLLBACK_COMMIT="$1"

if [ -z "$ROLLBACK_COMMIT" ]; then
  echo "‚ùå Usage: $0 <git-commit-hash>"
  echo "Example: $0 abc1234"
  exit 1
fi

echo "üîÑ Starting rollback to commit: $ROLLBACK_COMMIT"

# Confirm rollback
echo "‚ö†Ô∏è This will rollback ${this.config.target} to commit $ROLLBACK_COMMIT"
read -p "Are you sure? (y/N): " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
  echo "Rollback cancelled"
  exit 1
fi

# Verify commit exists
if ! git cat-file -e "$ROLLBACK_COMMIT^{commit}" 2>/dev/null; then
  echo "‚ùå Commit $ROLLBACK_COMMIT does not exist"
  exit 1
fi

# Create rollback branch
ROLLBACK_BRANCH="rollback-$(date +%Y%m%d-%H%M%S)"
echo "Creating rollback branch: $ROLLBACK_BRANCH"
git checkout -b "$ROLLBACK_BRANCH"

# Reset to target commit
echo "Resetting to commit: $ROLLBACK_COMMIT"
git reset --hard "$ROLLBACK_COMMIT"

# Clean build artifacts
echo "Cleaning build artifacts..."
rm -rf dist/ .vite/ node_modules/.cache/

# Rebuild
echo "Rebuilding application..."
npm install --legacy-peer-deps
npm run build

echo "‚úÖ Rollback completed successfully"
echo "üåø Current branch: $ROLLBACK_BRANCH"
echo "üì¶ Application rebuilt and ready for deployment"
echo ""
echo "Next steps:"
echo "1. Test the rolled-back version locally"
echo "2. Deploy using: npm run deploy:${this.config.environment}"
echo "3. Verify deployment functionality"
echo "4. If satisfied, merge rollback branch to main"
`;

    await writeFile(scriptPath, rollbackScript);
    logger.debug(`Generated rollback script: ${scriptPath}`);
  }

  /**
   * Update package.json with new build scripts
   */
  private async updatePackageJsonScripts(): Promise<void> {
    const packageJsonPath = join(this.config.projectPath, 'package.json');
    
    try {
      const packageJson = JSON.parse(await require('fs').promises.readFile(packageJsonPath, 'utf-8'));
      
      // Add new scripts
      packageJson.scripts = {
        ...packageJson.scripts,
        [`build:${this.config.environment}`]: `chmod +x build-scripts/build-${this.config.environment}.sh && ./build-scripts/build-${this.config.environment}.sh`,
        [`deploy:${this.config.environment}`]: `npm run build:${this.config.environment} && sams-deploy ${this.config.target} --env ${this.config.environment}`,
        'cache-bust': 'node build-scripts/cache-bust.js',
        'setup-version-notifications': 'node build-scripts/version-notifications.js',
        'verify-deployment': 'chmod +x build-scripts/verify-deployment.sh && ./build-scripts/verify-deployment.sh',
        'rollback': 'chmod +x build-scripts/rollback.sh && ./build-scripts/rollback.sh'
      };
      
      await writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2));
      logger.debug('Updated package.json with new build scripts');
      
    } catch (error) {
      logger.warn(`Failed to update package.json: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
}

/**
 * Convenience function to generate build configuration
 */
export async function generateBuildConfiguration(config: BuildScriptConfig): Promise<void> {
  const generator = new BuildScriptGenerator(config);
  await generator.generateBuildConfiguration();
}